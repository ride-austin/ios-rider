fastlane_version "1.109.0"

default_platform :ios

platform :ios do
  before_all do  
    ENV["FL_COCOAPODS_PODFILE"] = "./Podfile"
    ENV["FL_BUILD_NUMBER_PROJECT"] = "./Ride.xcodeproj"
    ENV["FL_HOCKEY_API_TOKEN"] = ENV["HOCKEYAPP_API_TOKEN"]
    ENV["PRECHECK_USERNAME"] = ENV["DELIVER_USERNAME"]
    xcversion(version: "11.3.0")
    setup_circle_ci
  end
  TARGETVERSION = 'RideAustin'
  HOCKEYAPP_ID_QA = ENV["HOCKEYAPP_ID_QA"]
  APP_IDENTIFIER_QA = ENV["APP_IDENTIFIER_QA"]
  APP_IDENTIFIER_PROD = ENV["APP_IDENTIFIER_PROD"]
  SLACK_URL_XOCHAT = ENV["SLACK_URL_XOCHAT"]
  TEAM_ID_PRODUCTION = ENV["TEAM_ID_PRODUCTION"]

  desc "Create Archive, Upload to hockey for QA"
  lane :qa do |values|
    ####################################################
    # if fastlane is triggered by increment build, quit
    old_build = get_build_number
    version = get_version_number(target: TARGETVERSION)
    unexpected_commit_message = "Version " +  version + " (" + old_build + ")"
    release_notes = last_git_commit[:message]
    if release_notes.include? unexpected_commit_message
      next
    end
    ####################################################

    raise "DONT FORGET HOCKEYAPP_API_TOKEN see https://confluence.devfactory.com/display/RA/Using+Fastlane" unless ENV["FL_HOCKEY_API_TOKEN"] != nil

    increment_build_number
    build   = get_build_number
    plist_command = "Set :CFBundleVersion " + build
    sh("/usr/libexec/PlistBuddy", "-c", plist_command, "../scripts/templates/RideAustin-Info.plist.template")
    version = get_version_number(target:TARGETVERSION)
    commit_message = "Version #{version} (#{build})"
    message = "#{TARGETVERSION} #{commit_message} uploaded by:#{ENV["DELIVER_USERNAME"]}"

    match(
      type: "development",
      force_for_new_devices: true,
      app_identifier: APP_IDENTIFIER_QA
    )

    gym(scheme: 'RideAustinTest', 
        export_method: 'development',
        silent: true,
        skip_profile_detection: true,
        export_options: {
          provisioningProfiles: {
            APP_IDENTIFIER_QA => "match Development #{APP_IDENTIFIER_QA}"
          }
        }
    )

    appcenter_upload(
      app_name: ENV["APPCENTER_APP_NAME"],
      owner_type: "organization",
      release_notes: release_notes
    )

    # Generated by _gym_
    dSYMPath = lane_context[SharedValues::DSYM_OUTPUT_PATH]        
    upload_symbols_to_crashlytics(dsym_path:dSYMPath)

    clean_build_artifacts
    sh("git add -A && git commit -m '#{commit_message}'")
    push_to_git_remote(tags:false)
  end

  desc "Create Archive, upload to itunesconnect - Production Austin"
  lane :prod do |values|
    match(type: "appstore",
          app_identifier: APP_IDENTIFIER_PROD)

    precheck(app_identifier: APP_IDENTIFIER_PROD,
             include_in_app_purchases: false,
             team_id: TEAM_ID_PRODUCTION)

    target  = 'RideAustin'
    build   = get_build_number
    test_version = get_version_number(target:TARGETVERSION)

    #remove b
    production_version = test_version.chomp("b") 
    commit_message = "Version #{production_version} (#{build})"
    set_info_plist_value(path: "./Resources/Plists/RideAustin-Info.plist", key:"CFBundleShortVersionString", value:production_version)

    gym(scheme: 'RideAustin',
        export_method: 'app-store')
    
    upload_to_testflight(skip_waiting_for_build_processing: true,
          beta_app_description:'Fixed bugs. Minor UI Enhancements.',
          demo_account_required: true,
          changelog: 'Fixed bugs. Minor UI Enhancements.',
          distribute_external: true, 
          team_id: TEAM_ID_PRODUCTION)
    
    # Generated by _gym_
    dSYMPath = lane_context[SharedValues::DSYM_OUTPUT_PATH]        
    upload_symbols_to_crashlytics(dsym_path:dSYMPath)
    clean_build_artifacts
    reset_git_repo(force: true, 
                   skip_clean: true)

    message = "#{target} #{commit_message} uploaded to iTunesConnect by: #{ENV["DELIVER_USERNAME"]}"
    slack(message: message)
    slack(message: message,
          slack_url: SLACK_URL_XOCHAT)
  end

  lane :prodaustin_refresh do
    download_dsyms(app_identifier: APP_IDENTIFIER_PROD)                  # Download dSYM files from iTC
    upload_symbols_to_crashlytics   # Upload them to Crashlytics
    clean_build_artifacts           # Delete the local dSYM files
  end

  desc "Run Unit Tests"
  lane :unit_tests do |values|
    scan(
      scheme: "RideAustinTest-Automation",
      clean: true,
      open_report: false,
      skip_build: false,
      device: "iPhone 6 (12.2)"
    )
  end

  lane :refresh_signing do |values|
    match(
      type: "development",
      force_for_new_devices: true,
      app_identifier: APP_IDENTIFIER_QA
    )

    gym(scheme: 'RideAustinTest', 
        export_method: 'development',
        silent: true,
        skip_profile_detection: true,
        export_options: {
          provisioningProfiles: {
            APP_IDENTIFIER_QA => "match Development #{APP_IDENTIFIER_QA}"
          }
        }
    )

    match(
      type: "appstore",
      app_identifier: APP_IDENTIFIER_PROD
    )
    gym(
      scheme: 'RideAustin',
      export_method: 'app-store'
    )
  end

  desc "Create production push certificates"
  lane :pushrenew do |values|
    force = values[:force]
    if force.nil? 
      force = false
    end
    get_push_certificate(
      development: false,
      force: force, # create a new profile, even if the old one is still valid
      app_identifier: APP_IDENTIFIER_PROD, # optional app identifier,
      save_private_key: true,
      new_profile: proc do |profile_path| # this block gets called when a new profile was generated
        puts profile_path # the absolute path to the new PEM file
        # insert the code to upload the PEM file to the server
      end
    )
  end

  desc "Create qa push certificates"
  lane :pushrenewdev do |values|
    force = values[:force]
    if force.nil? 
      force = false
    end
    get_push_certificate(
      development: true,
      force: force, # create a new profile, even if the old one is still valid
      app_identifier: APP_IDENTIFIER_QA, # optional app identifier,
      save_private_key: true,
      new_profile: proc do |profile_path| # this block gets called when a new profile was generated
        puts profile_path # the absolute path to the new PEM file
        # insert the code to upload the PEM file to the server
      end
    )
  end

  desc "Summary of all provisioning profiles needed"
  lane :matchall do |values|
    readonly = values[:readonly]
    if readonly.nil? 
      readonly = true
    end
    #app store
    match(type: "appstore",
          app_identifier: APP_IDENTIFIER_PROD,
          readonly:readonly)
    #hockeyapp
    match(type: "development",
          force_for_new_devices: true,
          app_identifier: APP_IDENTIFIER_QA,
          readonly:readonly)
  end
end
